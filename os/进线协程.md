# 进程
**进程状态切换**
**多进程模型**
**进程调度算法**
**进程同步**
**进程间通信方式**
**父进程、子进程、进程组和会话**
**进程终止**

# 线程
**线程通信方式**
**多线程模型**
**1.** 线程之间有无先后访问顺序；（线程依赖关系）
**2.** 多个线程共享访问同一变量（同步互斥问题）
**3.** 作为处理机调度的最小单位，线程调度只需要保存**线程栈、寄存器数据和PC**即可，相比进程切换开销要小很多。
**4.** 相关接口：
**4a.** 线程管理相关接口
```
//创建线程
int pthread_create(pthread_t *tidp,const pthread_attr_t *attr, void *(start_rtn)(void),void *arg);
//获取线程ID
pthread_t pthread_self();
//等待线程结束
/*
主线程调用，等待字线程退出并回收其资源，调用pthread_join的线程会被阻塞
*/
int pthread_join(pthread_t tid, void** retval);
//结束线程
pthread_exit(void *retval);
//分离线程
int pthread_detach(pthread_t tid)
```
**4b.** 线程属性值
```
//线程属性对象类型
struct{
    int detachstate;    // 线程分离的状态
    int schedpolicy;    // 线程调度策略
    struct sched_param schedparam;    // 线程的调度参数
    int inheritsched;    // 线程的继承性
    int scope;    // 线程的作用域
    // 以下为线程栈的设置
    size_t guardsize;    // 线程栈末尾警戒缓冲大小
    int stackaddr_set;    // 线程的栈设置
    void *    stackaddr;    // 线程栈的位置
    size_t stacksize;    // 线程栈大小
}pthread_attr_t;

//设置线程属性
pthread_attr_get()
//获取线程属性
pthread_attr_set()
```
# 协程
# 进程、线程与协程
|| 进程 | 线程 | 协程 |
| -: | --: | --: | --: |
| 定义 | 资源分配和拥有的基本单位 | 程序执行的基本单位 | 用户态的轻量级线程，线程内部调度的基本单位 |
| 切换情况 | 进程CPU环境（栈、寄存器、页表和文件句柄）的保存及新调度的进程CPU环境的设置 | 保存和设置程序计算器、少量寄存器和栈的内容 | 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复 |
| 切换者 | OS | OS | 用户 |
| 切换过程 | 用户态->内核态->用户态 | 用户态->内核态->用户态 | 用户态（没有陷入内核） |
| 调用栈 | 内核栈 | 内核栈 | 用户栈 |
| 拥有资源 | CPU资源、内存资源、文件资源和句柄 | 程序计数器、寄存器、栈和状态字 | 拥有自己的寄存器上下文和栈 |
| 并发性 | 不同进程之间切换并发，各自占有C PU实现并行 | 一个进程内部的多个线程并发执行 | 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 |
| 系统开销 | 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高效缓存失效，页表切换，开销很大 | 切换时只需保存和设置少量寄存器内容，开销很小 | 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文切换非常快 |
| 通信方式 | 进程间通信需要借助操作系统 | 线程间可以直接读写进程数据段（如全局变量）来进行通信 | 共享内存、消息队列 |
注：线程使用有一定难度，需要处理数据一致性问题；同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈。
